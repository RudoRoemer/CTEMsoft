! ###################################################################
! Copyright (c) 2013, Marc De Graef/Carnegie Mellon University
! All rights reserved.
!
! Redistribution and use in source and binary forms, with or without modification, are 
! permitted provided that the following conditions are met:
!
!     - Redistributions of source code must retain the above copyright notice, this list 
!        of conditions and the following disclaimer.
!     - Redistributions in binary form must reproduce the above copyright notice, this 
!        list of conditions and the following disclaimer in the documentation and/or 
!        other materials provided with the distribution.
!     - Neither the names of Marc De Graef, Carnegie Mellon University nor the names 
!        of its contributors may be used to endorse or promote products derived from 
!        this software without specific prior written permission.
!
! THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" 
! AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
! IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE 
! ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE 
! LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL 
! DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR 
! SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER 
! CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, 
! OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE 
! USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
! ###################################################################

!--------------------------------------------------------------------------
! CTEMsoft2013:CTEMmbcbed.f90
!--------------------------------------------------------------------------
!
! PROGRAM: CTEMmbcbed 
!
!> @author Marc De Graef, Carnegie Melon University
!
!> @brief Zone axis CBED
!
!> @todo add HOLZ lines and Bethe potentials; take from EBSD code most likely... 
! 
!> @date  11/29/01 MDG 1.0 original
!> @date 04/08/13 MDG 2.0 rewrite
!
!--------------------------------------------------------------------------
program CTEMmbcbed

use local
use io
use symmetryvars
use symmetry
use crystal
use files
use diffraction
use postscript

IMPLICIT NONE

real(kind=sgl)			:: io_real(1)

! first get the crystal data and microscope voltage
 SG%SYM_reduce=.TRUE.
 call CrystalData
 call GetVoltage

 call ReadValue(' Camera length L  [mm, real] ', io_real, 1)
 camlen = io_real(1)

! generate all atom positions
 call CalcPositions('v')

! generate a set of zone axis CBED patterns
 call MBCBEDpage

end program

!--------------------------------------------------------------------------
!
! SUBROUTINE:MBCBEDPage
!
!> @author Marc De Graef, Carnegie Melon University
!
!> @brief draw zone axis convergent beam electron diffraction patterns
!
! 
!> @date 11/29/01   MDG 1.0 original
!> @date 04/08/13 MDG 2.0 rewrite
!--------------------------------------------------------------------------
subroutine MBCBEDpage

use local
use constants
use crystal
use crystalvars
use diffraction
use gvectors
use kvectors
use postscript, ONLY: GetIndex
use symmetry
use math
use dynamical
use io
use files

IMPLICIT NONE

real(kind=sgl)      			:: laL,kt,z0,thc,thb,hkl(3),ind(3),fn(3),ktmax, io_real(3), &
                       				   dom,glen,qr,qi,bg,xgpz,bragg,c(3),RR,gx(3),gy(3),gg(3), thetac, thick, &
                       				   sc, scmax, PX, PY, qx, qy, frac
integer(kind=irg)   			:: g(3),ira,dpcnt,ppi,ijmax,ga(3),gb(3),k(3),fcnt,ccnt,cnt, &
                       				  newcount,count_rate,count_max, io_int(6), i, j, isym, ir, order, nn, &
                       				  iorder, npx, npy, numt, im, numk, npix, ik, ip, jp
character(1)        			:: ans
character(2)        			:: srza
character(132)     			:: fname

complex(kind=sgl)   		:: czero
logical             				:: overlap,np,first
real(kind=sgl),parameter     	:: xoff(0:5)=(/0.0,3.3125,0.0,3.3125,0.0,3.3125/),yoff(0:5)=(/6.0,6.0,3.0,3.0,0.0,0.0/)
real(kind=sgl),allocatable    	:: disk(:,:,:)
integer(kind=irg),allocatable 	:: diskoffset(:,:)
real(kind=sgl),allocatable    	:: inten(:,:)

! zone axis computation
 srza = 'ZA'

! get k and f
 mess = ' Enter wave vector direction'; call Message("(/A)")
 call GetIndex(k,'d')
 mess = ' Enter foil normal'; call Message("(/A)")
 call GetIndex(g,'d')
 DynFN = float(g)
 
! determine the point group number
 j=0
 do i=1,32
  if (SGPG(i).le.cell % SYM_SGnum) j=i
 end do
! and the Bright Field symmetry
 call BFsymmetry(k,j,isym,ir)
 io_int(1:3) = k(1:3)
 call WriteValue('', io_int, 5, "(//,' ','[',3I2,'] has Bright Field symmetry ',$)")
 mess = PGTWD(isym)
 call Message("(A,$)")
 io_int(1) = ir 
 call WriteValue('; order = ',io_int, 1, "(I4,//)")


! determine the shortest reciprocal lattice points for this zone
 call ShortestG(k,ga,gb,isym)
 io_int(1:3)=ga(1:3)
 io_int(4:6)=gb(1:3)
 call WriteValue(' Reciprocal lattice vectors : ', io_int, 6,"('(',3I3,') and (',3I3,')',/)")

! determine all families of reciprocal lattice points
! that belong to the zone/row and rank them
  call RankReflections(k,ga,gb,fcnt,srza,iorder)

! then select the reflections needed for the simulation
  call SelectReflections(fcnt,nn,ccnt)

! enter range of incident beam directions
  mess = ' The program will use a symmetric cone of beam directions,'; call Message("(/A)")
  mess = ' centered on the incident beam direction entered above.'; call Message("(A)")
  bragg = CalcDiffAngle(ga(1),ga(2),ga(3))*0.5*1000.0
  io_real(1) = bragg
  call WriteValue(' The Bragg angle for the first reflection is equal to [mrad]: ',io_real, 1, "(F8.5)")

  call ReadValue(' Enter the beam convergence angle theta_c in mrad: ', io_real, 1)
  thetac = io_real(1)/1000.0
  
! convert to ktmax along ga
  ktmax = 0.5*thetac*1000.0/bragg

! compute number of pixels along diameter of central disk for given camera length
  RR = 300.0/25.4   ! dots per millimeter for 300 dots per inch
  npx = nint(RR*camlen*thetac)
  npy = npx
  io_int(1) = 2.0*npx
  call WriteValue(' Number of image pixels along diameter of central disk = ', io_int, 1, "(I4)")

  ijmax = float(npx)**2   ! truncation value for beam directions
! get number of thicknesses for which to compute the CBED pattern
  call ReadValue(' Enter the first thickness [nm, R]', io_real, 1)
  thick = io_real(1)
  call ReadValue(' How many multiples of this thickness [I] ', io_int, 1) 
  numt = io_int(1)
  
! determine all independent incident beam directions (use a linked list starting at khead)
  call Calckvectors(dble(k),dble(ga),dble(ktmax),npx,npy,numk,isym,'Standard')

!  call Calckvectors(im,k,ga,ktmax,isym,npx,npy,nn,numk,ijmax)

! next, initialize the off-diagonal part of the dynamical matrix DynMat
  call CalcDynMat('BLOCH')

! allocate the disk variable which will hold the entire computed pattern
  npix = int(3.0*300.0)   ! 3 inches wide at 300 dpi
  allocate(disk(numt,npix,npix))
  disk=0.0
  
! compute the offset parameters for all diffraction disks
! first normalize the zone axis in cartesian components; this is the z-axis
  call TransSpace(float(k),c,'d','c')
  call NormVec(c,'c')

! then make ga the x-axis
  call TransSpace(float(ga),gx,'r','c')
  call NormVec(gx,'c')

! compute the cross product between k and gx; this is the y-axis
  call CalcCross(c,gx,gy,'c','c',0)

! allocate the offset array
  allocate(diskoffset(DynNbeams,3))
  diskoffset = 0
  rltmpa => reflist%next
  sc = mLambda*camlen*RR
  scmax = 1.5*300.0 + npx
  PX = npix/2

! project every g-vector onto gx and gy to get the components
  do i=1,DynNbeams
    gg(1:3)=float(rltmpa%hkl)
    call TransSpace(gg,c,'r','c')
    qx= CalcDot(c,gx,'c')*sc
    qy= CalcDot(c,gy,'c')*sc
    if ((abs(qx).lt.scmax).and.(abs(qy).lt.scmax)) then
      diskoffset(i,1) = 1
      diskoffset(i,2) = nint(qx)
      diskoffset(i,3) = nint(qy)
    else
      diskoffset(i,1) = 0
    end if
    rltmpa => rltmpa%next
  end do
  
! allocate the intensity array
  allocate(inten(numt,DynNbeams))
  inten = 0.0
  frac = 0.05

  io_int(1)=numk
  call WriteValue(' Starting computation for # beam directions = ', io_int, 1, "(I6)")

! time the computation
  cnt = 0
  call system_clock(cnt,count_rate,count_max)

! point to the first beam direction
  ktmp => khead
! loop over all beam orientations, selecting them from the linked list
  do ik = 1,numk
! compute the diagonal part of the dynamical matrix 
   DynWV = ktmp%k
   call CalcDynMat('DIAGB')
   
! solve the dynamical eigenvalue equation
   call CalcBWint(DynNbeams,numt,thick,inten)

! and copy the intensities in the correct locations
   do i=1,DynNbeams
    if (diskoffset(i,1).eq.1) then
      ip = PX + diskoffset(i,2) - ktmp%i
      jp = PX + diskoffset(i,3) + ktmp%j

! is this point inside the viewing square ?
      if (((ip.ge.1).and.(ip.le.npix)).and.((jp.ge.1).and.(jp.le.npix))) then
        do j=1,numt
         disk(j,ip,jp) = disk(j,ip,jp) + inten(j,i)
        end do
      end if
    end if
   end do

! select next beam direction
   if (ik.ne.numk) ktmp => ktmp%next

! update computation progress
   if (float(ik)/float(numk) .gt. frac) then
    io_int(1) = nint(100.0*frac) 
    call WriteValue('       ', io_int, 1, "(1x,I3,' percent completed')") 
    frac = frac + 0.05
   end if  
   inten = 0.0
  end do
! stop the clock and report the total time     
  call system_clock(newcount,count_rate,count_max)
  io_real(1)=float(newcount-cnt)/float(count_rate)
  call WriteValue(' Total computation time [s] ' , io_real, 1, "(F)")

 loadingfile = .FALSE.
  call SafeOpenFile('d1','unformatted',fname)
  write (dataunit) numt,npix
  write (dataunit) disk
  call SafeCloseFile('d1','keep',fname)

end subroutine MBCBEDpage


  
! next, allocate memory for the wave functions/Bloch wave parameters
!   if (.not.allocated(W)) then 
!    allocate(W(nn),stat=istat)
!    if (istat.ne.0) call FatalError('Calckvectors: unable to allocate memory for W',' ')
!   end if 
!   if (.not.allocated(CG)) then 
!    allocate(CG(nn,nn),stat=istat)
!    if (istat.ne.0) call FatalError('Calckvectors: unable to allocate memory for CG',' ')
!   end if 
!   if (.not.allocated(alpha)) then 
!    allocate(alpha(nn),stat=istat)
!    if (istat.ne.0) call FatalError('Calckvectors: unable to allocate memory for alpha',' ')
!   end if 
!
!
!
! ###################################################################
! 
!  subroutine CalcBW
! 
!  Author: Marc De Graef
!  
!  Description: integrate the dynamical equations using the Bloch Wave
!  formalism.
! 
!  History
! 
!  modified by  rev reason
!  -------- --- --- -----------
!  10/13/98 MDG 1.0 original
!   7/04/01 MDG 2.0 f90
! ###################################################################
subroutine CalcBWint(nn,nt,thick,inten)

use local
use io
use diffraction
use kvectors
use dynamical
use constants

IMPLICIT NONE

integer(kind=irg)                             	:: nn,i,j,ig,ih,IPIV(nn),nt
complex(kind=dbl),allocatable    		:: CGinv(:,:), Minp(:,:),diag(:),Wloc(:)
real(kind=sgl)                             		:: thick,inten(nt,nn),th
complex(kind=dbl)                			:: Ijk(nn,nn),Lgh(nn,nn),q


intent(IN)      :: nn,thick
intent(OUT)     :: inten

! allocate space for the Bloch wave eigenvalue routine
allocate(CGinv(DynNbeams,DynNbeams),Minp(DynNbeams,DynNbeams),diag(DynNbeams),Wloc(DynNbeams))

! compute the eigenvalues and eigenvectors
 Minp = DynMat
 IPIV = 0
 call BWsolve(Minp,Wloc,CG,CGinv,nn,IPIV)

! the alpha coefficients are in the first column of the inverse matrix
! the minus sign in W(i) stems from the fact that k_n is in the direction
! opposite to the foil normal
 W = cPi*Wloc/cmplx(ktmp%kn,0.0)
 do i=1,nn
  alpha(i) = CGinv(i,1)
 end do

 do i=1,nt
  th = dble(thick*float(i))
  diag(1:nn)=exp(-th*imag(W(1:nn)))*cmplx(cos(th*real(W(1:nn))),sin(th*real(W(1:nn))))*alpha(1:nn)
  do j=1,nn
   inten(i,j) = abs(sum(CG(j,1:nn)*diag(1:nn)))**2
  end do 
 end do

 deallocate(CGinv,Minp,diag,Wloc)
 
end subroutine CalcBWint
