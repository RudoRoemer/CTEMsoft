
\documentclass[DIV=calc, paper=letter, fontsize=11pt]{scrartcl}	 % A4 paper and 11pt font size

\usepackage[body={6.5in,9.0in},
  top=1.0in, left=1.0in]{geometry}
  
\usepackage[english]{babel} % English language/hyphenation
\usepackage[protrusion=true,expansion=true]{microtype} % Better typography
\usepackage{amsmath,amsfonts,amsthm} % Math packages
\usepackage[svgnames]{xcolor} % Enabling colors by their 'svgnames'
\usepackage[hang, small,labelfont=bf,up,textfont=it,up]{caption} % Custom captions under/above floats in tables or figures
\usepackage{booktabs} % Horizontal rules in tables
\usepackage{fix-cm}	 % Custom font sizes - used for the initial letter in the document
\usepackage{epsfig}
\usepackage{sectsty} % Enables custom section titles
\allsectionsfont{\usefont{OT1}{phv}{b}{n}} % Change the font of all section commands

\usepackage{fancyhdr} % Needed to define custom headers/footers
\pagestyle{fancy} % Enables the custom headers/footers
\usepackage{lastpage} % Used to determine the number of pages in the document (for "Page X of Total")
\usepackage{color}

\usepackage{fancyvrb}% used to include files verbatim
%\usepackage{chemsym}

\usepackage{hyperref}

\usepackage[backend=bibtex,style=numeric,sorting=ydnt,maxnames=15]{biblatex}
\renewbibmacro{in:}{}

% Count total number of entries in each refsection
\AtDataInput{%
  \csnumgdef{entrycount:\therefsection}{%
    \csuse{entrycount:\therefsection}+1}}

% Print the labelnumber as the total number of entries in the
% current refsection, minus the actual labelnumber, plus one
\DeclareFieldFormat{labelnumber}{\mkbibdesc{#1}}    
\newrobustcmd*{\mkbibdesc}[1]{%
  \number\numexpr\csuse{entrycount:\therefsection}+1-#1\relax}


%\addbibresource[label=papers]{mypubs.bib}
%\addbibresource[label=books]{mypubs.bib}
%\addbibresource[label=edited]{mypubs.bib}
%\addbibresource[label=chapters]{mypubs.bib}


% Headers - all currently empty
\lhead{}
\chead{}
\rhead{}

% Footers
\lfoot{\textsf{CTEMKossel} manual, v1.0, \today}
\cfoot{}
\rfoot{\footnotesize Page \thepage\ of \pageref{LastPage}} % "Page 1 of 2"

\renewcommand{\headrulewidth}{0.0pt} % No header rule
\renewcommand{\footrulewidth}{0.4pt} % Thin footer rule

\usepackage{lettrine} % Package to accentuate the first letter of the text
\newcommand{\initial}[1]{ % Defines the command and style for the first letter
\lettrine[lines=3,lhang=0.3,nindent=0em]{
\color{DarkGoldenrod}
{\textsf{#1}}}{}}

\usepackage{titling} % Allows custom title configuration

\newcommand{\HorRule}{\color{DarkGoldenrod} \rule{\linewidth}{1pt}} % Defines the gold horizontal rule around the title

\pretitle{\vspace{-1.5in} \begin{center} \HorRule \fontsize{25}{25} \usefont{OT1}{phv}{b}{n} \color{DarkRed} \selectfont} % Horizontal rule before the title

\title{Electron Kossel Pattern Simulations} % Your article title

\posttitle{\par\end{center}\vskip 0.5em} % Whitespace under the title

\preauthor{\begin{center}\large \lineskip 0.5em \usefont{OT1}{phv}{b}{sl} \color{DarkRed}} % Author font configuration

\author{\vspace*{-0.7in}} % Your name

\postauthor{\footnotesize \usefont{OT1}{phv}{m}{sl} \color{Black} % Configuration for the institution name

\par\end{center}\HorRule} % Horizontal rule after the title
\date{Program Manual, v1.0, \today}

\newcommand{\ctp}{\textsf{CTEMsoft-2013}}
%
\newcommand{\upg}[1]{\mathrm{i}U_{\mathbf{#1}}^{\prime}}
\newcommand{\combo}[1]{U_{\mathbf{#1}}+\upg{#1}}
\newcommand{\upgcombo}[2]{2k_{0}s_{\mathbf{#1}}+\upg{#2}}
\newcommand{\ugh}[2]{U_{\mathbf{#1}-\mathbf{#2}}}
\newcommand{\ughp}[2]{U_{\mathbf{#1}'-\mathbf{#2}}}
\newcommand{\ughpp}[2]{U_{\mathbf{#1}-\mathbf{#2}'}}
\newcommand{\kkg}[1]{k_{0}^{2}-(\mathbf{k}+\mathbf{#1})^{2}}
\newcommand{\Cg}[1]{C_{\mathbf{#1}}}
\newcommand{\Cgj}[2]{C_{\mathbf{#1}}^{(#2)}}
\newcommand{\Cgjp}[2]{C_{\mathbf{#1}'}^{(#2)}}
\newcommand{\Cgja}[2]{C_{\mathbf{#1}}^{(#2)\ast}}
\newcommand{\button}[1]{\colorbox{green}{\textsf{#1}} button}


\begin{document}
\maketitle

\begin{figure*}[h]
\leavevmode\centering
\epsffile{figs/CTEMlogo}
\end{figure*}

\renewcommand{\contentsname}{Table of Contents}
{\small\tableofcontents}

\newpage
\section{Introduction}
This manual describes a set of two programs, 
one written in Fortran-90,\footnote{f90 is a much richer language than the original fortran-f77, and is
used for all programs in the \ctp\ package.} 
the other in IDL,\footnote{The \textit{Interactive Data Language} is an interpreted scripting language with extensive graphics capabilities.} 
that can be used for the simulation of regular zone axis electron Kossel diffraction patterns (EKP).  The main f90 program
is named \textsf{CTEMKossel} (note that all programs in the \ctp\ package start with the letters ``CTEM'').
The output generated by this program can then be visualized by the IDL routine \textsf{KosselDisplay.pro}.  

On the following pages we will try to accomplish four tasks:
\begin{enumerate}
	\item Explain briefly the underlying pattern formation theory and the numerical approach followed by the f90 programs (section~\ref{sec:theory});
	\item Document the input file for the f90 programs (section~\ref{sec:f90Kossel});
	\item Document the IDL interface (section~\ref{sec:idl});
	\item Explain the use of these programs by means of a basic example (section~\ref{sec:examples}).
\end{enumerate}

\input{common.tex}

\newpage
\section{Electron Kossel patterns: the underlying theory\label{sec:theory}}
The program described in this manual implements a dynamical model for electron diffraction using the 
Bloch wave approach.  In this section, we describe briefly the Bloch wave approach as well as the 
use of Bethe potentials to reduce the size of the dynamical matrix.  The combination of these 
two approaches is used in the f90 program described in this manual.

\subsection{The Bloch wave model}
We start from the basic Schr{\"o}dinger equation for high energy electrons:
\begin{equation}
	\Delta\Psi+4\pi^2k_0^2\Psi=
	-4\pi^2\left[U+\mathrm{i}U^{\prime}\right]\Psi,
	\label{eq:start}
\end{equation}
where the first term represents the kinetic energy, the second term the total energy (corrected for 
refraction), and the right hand side represents the interaction with the crystal lattice; $k_0$ represents
the refraction corrected relativistic wave number, $U$ is the position-dependent electrostatic lattice 
potential (scaled by $2me/h^2$), and $U'$ is the corresponding absorptive potential; the combination of the 
two is often refered to as the ``optical potential.''  For all computations in the \ctp\ package, we make use 
of the Weickenmeier \& Kohl atomic scattering factors and absorptive form factors.\footnote{A.~Weickenmeier and H.~Kohl,
Computation of {A}bsorptive {F}orm {F}actors for {H}igh-{E}nergy {E}lectron {D}iffraction,{\em Acta Crystall.\ A}, 47:590--597, 1991.}

The Bloch wave approach\footnote{For a basic introduction, see C.J. Humphreys,
The {S}cattering of {F}ast {E}lectrons by {C}rystals, {\em Rep.\ Prog.\ Phys.}, 42:1825--1887, 1979.}
starts from the assumption that the wave function inside the crystal
is a superposition of states that have the periodicity of the lattice, but does not make any
assumption about the allowed wave vectors inside the crystal.  The wave function is then 
assumed to be of the form 
\begin{equation}
	\Psi(\mathbf{r})=\sum_j\alpha^{(j)}\sum_{\mathbf{g}}\Cgj{g}{j} 
	\mathrm{e}^{2\pi \mathrm{i}(\mathbf{k}^{(j)} +\mathbf{g})\cdot\mathbf{r}}=
        \sum_j\alpha^{(j)}C^{(j)}(\mathbf{r})\mathrm{e}^{2\pi \mathrm{i}
        \mathbf{k}^{(j)}\cdot\mathbf{r}}
	\label{eq:blochexpansion2}
\end{equation}
The coefficients
$\Cgj{g}{j}$ are known as the \textit{Bloch wave coefficients}, 
while the coefficients $\alpha^{(j)}$ are the \textit{excitation amplitudes}.
Each of the functions $C^{(j)}(\mathbf{r})$ has the periodicity of the lattice.
Using the high energy approximation one can show that the number of coefficients is
equal to the number of scattered beams.  

When absorption is taken into account, one can show that the problem is reduced
to the determination of the eigenvalues and eigenvectors of the dynamical matrix below:
\begin{equation}
	\left(\begin{matrix}
	\upg{0} & \combo{-g} & \ldots & \combo{-h}\\
	\combo{g} & \upgcombo{g}{0} & \ldots & \combo{g-h}\\
	\vdots  &  \vdots &  \ddots  &  \vdots\\
	\combo{h} & \combo{h-g} & \ldots & \upgcombo{h}{0}
	\end{matrix}\right)
	\left(\begin{matrix}
	\Cgj{0}{j}\\ \Cgj{g}{j}\\ \vdots\\ \Cgj{h}{j}
	\end{matrix}\right)=2k_{n}\Gamma^{(j)}\left(\begin{matrix}
	\Cgj{0}{j}\\ \Cgj{g}{j}\\ \vdots\\ \Cgj{h}{j}
	\end{matrix}\right).\label{eq:blochmatrixabs}
\end{equation}
From a computational point of view, this is about the most difficult eigenvalue problem to solve, since 
the matrix is non-symmetric and complex.  In the \ctp\ package, we make use of a standard routine (\textsf{zgeev}) from the LAPACK
library to solve this problem.

Once the eigenvectors and eigenvalues are known, we need to apply the boundary condition at the 
entrance plane (typically that all amplitude is in the incident beam and none in the scattered beams at $z=0$).
One can show that the Bloch wave excitation amplitudes $\alpha^{(j)}$ are given by the first column of the 
inverse of the eigenvector matrix; we use the \textsf{zgetrf} and \textsf{zgetri} LAPACK routines to compute 
this inverse matrix.

Finally, the probability that an incident beam electron will still be in the incident Bloch
wave after traversing a crystal thickness $z$ is computed by substituting the eigenvalues and excitation
amplitudes in the following expression:
\begin{equation}
	P(z,\mathbf{k}_0) = \sum_j \vert \alpha^{(j)}\vert^2 e^{-4\pi q^{(j)}z}.\label{eq:EKP}
\end{equation}
This computation is then repeated for each of the incident beam directions, and the results are collected and displayed as an 
electron Kossel pattern.

\subsection{Bethe potentials to reduce the dynamical matrix size}
The dynamical matrix can become quite large, in particular when the incident beam is close to a zone
axis orientation.  The computation of eigenvalues and eigen vectors goes as $N^3$, where $N$ is the number
of beams taken into account, so even a small reduction of $N$ can have a significant effect on the 
computation time.  The standard approach is to split the scattered beams into two groups: strong
beams, for which the computation is done explicitly, and weak beams, which are treated as a 
perturbation on the strong beam dynamical matrix.

If we represent the optical potential by $U$, then one can show that substitution of the 
Bloch wave expression into the Schr{\"o}dinger equation, and application 
of the high energy approximation, results in the following system of equations:  
\[
	2k_{0}s_{\mathbf{g}}\Cgj{g}{j} + \sum_{\mathbf{h}\neq
	\mathbf{g}}\ugh{g}{h}\Cgj{h}{j}=2k_{n}\Gamma^{(j)}\Cgj{g}{j}.
\]
where $s_{\mathbf{g}}$ are the excitation errors, and $k_n$ is the normal 
component of the incident wave vector.
If the prefactor of the first term $(k_{0}\vert s_{\mathbf{g}}\vert)$
is significantly larger than the prefactor of the second term
$(\vert\ugh{g}{h}\vert)$, then the coupling of $\mathbf{g}$ to
$\mathbf{h}$ will be weak.  Let us rewrite this eigenvalue equation as
follows:
\[
\eta^{(j)}_{\mathbf{g}}\Cgj{g}{j} + \sum_{\mathbf{h}\neq
	\mathbf{g}}\ugh{g}{h}\Cgj{h}{j}= 0,
\text{ with }
\eta^{(j)}_{\mathbf{g}}\equiv 2[k_{0}s_{\mathbf{g}} - k_{n}\Gamma^{(j)}].
\]
We will denote weak beams by primed reciprocal lattice vectors, e.g., 
$\mathbf{g}'$. We will also assume that weak beams do not interact 
with each other, only with strong beams.  After a bit of mathematics,
one can show that to first order, the above system of equations can
be replaced by a new, smaller system where the sum only covers the strong beams:
\[
\bar{\eta}^{(j)}_{\mathbf{g}}\Cgj{g}{j} + \sum_{\mathbf{h}\neq
	\mathbf{g}}\bar{U}_{\mathbf{g}-\mathbf{h}}\Cgj{h}{j}= 0,
\]
The perturbed excitation errors and potential 
coefficients can be written as:
\begin{align*}
    2k_0\bar{s}_{\mathbf{g}} &\equiv 2k_0s_{\mathbf{g}}- 
    \sum_{\mathbf{h}'}\frac{\vert\ughpp{g}{h}\vert^{2}} 
    {2k_0s_{\mathbf{h}'}};\\
    \bar{U}_{\mathbf{g}-\mathbf{h}} &\equiv \ugh{g}{h}
    -\sum_{\mathbf{h}'}\frac{\ughpp{g}{h}\ughp{h}{h}}
    {2k_0s_{\mathbf{h}'}},
\end{align*}
We have replaced the excitation errors of the strong beams by effective
excitation errors; the Fourier coefficients of the electrostatic
lattice potential have also been modified to take the weaker beams
into account.  The coefficients $\bar{U}_{\mathbf{g}-\mathbf{h}}$ are
known as \textit{Bethe potentials} or \textit{dynamical potentials}. 
This approximation was first introduced by Bethe in 1928 using first order
perturbation theory.

It is not unusual for the Bethe potential approximation to allow for a 
reduction of the number of beams by a factor of $2$, thus speeding up
the computation of the eigenvalues and eigenvectors by a factor of $8$.
Once the Bloch wave coefficients of all the strong beams are known, then 
the following equation can be used to determine the Bloch wave coefficients of the weaker 
beams (and hence also their intensity):
\begin{equation}
    \Cgjp{g}{j} = -\frac{1}{\eta^{(j)}_{\mathbf{g}'}}
    \sum_{\mathbf{h}}\ughp{g}{h}\Cgj{h}{j}.\label{eq:weakCgj}
\end{equation}
While the Bethe potential approach is conceptually not that difficult, it is clear that efficient implementation 
of this approach in a framework that functions properly for arbitrary crystal symmetry
requires a bit of sophistication in the algorithm.

The Bethe potential criteria can be implemented in a number of different ways, but 
require the definition of one or more threshold levels.  Currently,
the program user has some control over the threshold between strong and weak beams. 
As will be described in more detail in section~\ref{sec:f90BetheParameters}, there are two user-adjustable 
threshold levels, called ``\textsf{cutoff}'' and ``\textsf{weakcutoff}''; if we represent
them by $c_1$ and $c_2$, respectively, then the following relations hold for a beam 
with potential coefficient $\vert U_{\mathbf{g}}\vert$ and excitation error $s_{\mathbf{g}}$:
\begin{align*}
	0 & \le  \vert s_{\mathbf{g}}\vert \le c_2\lambda\vert U_{\mathbf{g}}\vert\rightarrow \text{ $\mathbf{g}$ is a strong beam};\\
	c_2\lambda\vert U_{\mathbf{g}}\vert &\le \vert s_{\mathbf{g}}\vert \le c_1\lambda\vert U_{\mathbf{g}}\vert\rightarrow \text{ $\mathbf{g}$ is a weak beam};\\
	c_1\lambda\vert U_{\mathbf{g}}\vert &\le \vert s_{\mathbf{g}}\vert \rightarrow\text{ $\mathbf{g}$ can be ignored}.
\end{align*}
This is a simplistic criterion for distinguishing between weak and strong beams.  While the results of computations with this criterion
are quite good (see section~\ref{sec:examples}), one could argue that a better criterion (but a bit more difficult to implement) 
would be the following:  above it was stated that the coupling between two beams $\mathbf{g}$ and $\mathbf{h}$ is considered 
to be weak, if $k_0\vert s_{\mathbf{g}}\vert \gg \vert U_{\mathbf{g}-\mathbf{h}}\vert$.  So, in order for a beam to be weak, this relation
has to be satisfied for all beams $\mathbf{g}$.  Therefore, for each potentially weak beam, we need to compare the corresponding 
potential coefficients for all the other beams to their respective excitation errors.  This alternative thresholding approach will undergo
some testing before implementation (if it is deemed to produce better results in terms of computation time).  

As a final comment in this section we might state that it is possible to extend the Bethe potential approximation to the next perturbation
order; preliminary numerical tests have shown that this results in an additional computational gain, at the expense of more complicated
code.  In the current version of the source code, the first order Bethe potential approximation is used.

\newpage
\section{The \protect\textsf{CTEMKossel.f90} program\label{sec:f90Kossel}}

\subsection{Program overview\label{sec:f90overviewKossel}}
This is a very basic program for electron Kossel pattern computations.  The main output of 
this program is a file containing the complete EKPs for a range of sample thickness values, 
out to some user-defined beam convergence angle.  

The program makes use of symmetry (diffraction groups) when appropriate to speed 
things up a bit.  The main computation proceeds as follows:
\begin{itemize}
	\item read input parameters;
	\item determine, for the given zone axis direction and beam convergence angle, 
	which reflections could potentially contribute to the scattering process;
	\item for those reflections, pre-compute all the potential Fourier coefficients;
	\item loop over all beam directions in the incident cone:
	\begin{itemize}
		\item determine the dynamical matrix, using the Bethe potential method (i.e.,
		for all participating beams, split them into strong and weak beams);
		\item solve the eigenvalue problem to obtain all intensities (for a range of 
		sample thicknesses);
		\item add together the contributions from all strong diffracted beams;
	\end{itemize}
	\item store all diffraction disks and associated data in a binary file for visualization in IDL.
\end{itemize}
This program can take a while to run, depending on the complexity of the crystal structure,
as well as on the beam convergence angle and requested disk size (see next section for parameter 
definitions).  It would make sense to speed things up a bit by using OpenMP calls, but that has not yet
been implemented (as of \today).

\subsection{Namelist input files\label{sec:f90inputKossel}}
The input file for this program, \textsf{CTEMKossel.nml}, is formatted as follows:
\fvset{frame=lines,formatcom=\color{blue},fontsize=\footnotesize}
\VerbatimInput{../templatefolder/CTEMKossel.template}
Most of these entries are self-explanatory.  The program will not run
without a valid crystal structure file name (xtalname).  The output
file can become large; its size is proportional to the product 
of (2npix+1)$^2$ and numthick  For representative 
examples of the input file, see the examples in section~\ref{sec:examples}.

\subsection{Bethe parameters namelist file\label{sec:f90BetheParameters}}
The Bethe potential approximation used in this program can be adjusted by the
user via the \textsf{BetheParameters.nml} namelist file, which must be present 
in the folder in which the program is executed; if this file is not present, then the
program will assume default values for all three parameters.  The values shown below
are the current program defaults.
\fvset{frame=lines,formatcom=\color{blue},fontsize=\footnotesize}
\VerbatimInput{../templatefolder/BetheParameters.template}
The last parameter sets the excitation error cutoff level for double diffraction reflections.  The issue with
such reflections is that they have a zero structure factor (and hence $U_{\mathbf{g}} = 0$), so that 
the standard Bethe potential threshold approach can not be used at all.  The current implementation
allows the user to set a threshold for the excitation error (in nm$^{-1}$) above which the double diffraction reflection
will not contribute at all.  Recall that double diffraction reflections can only occur in so-called non-symmorphic 
space groups, i.e., in space groups that have at least one screw axis or glide plane symbol in their space 
group symbol; in other words, in the space group \textbf{Fm$\bar{\mathbf{3}}$m}, there are no glides or screws in
the symbol, so double diffraction reflections are not possible for \textit{any} zone axis orientation.  For the space group \textbf{P6$_{\mathbf{3}}$/mmm},
on the other hand, there is a $6_3$ screw axis in the space group symbol, therefore it is possible for certain
zone axes to display double diffraction reflections.  The Kossel programs automatically take these reflections into account, but the user must
set the excitation error threshold value, or accept the program default.

It is also important to note that the value of the \textsf{weakcutoff} parameter should always be less that
that of the \textsf{cutoff} parameter if one wants to make use of the Bethe approximation.  Testing has shown
that a \textsf{weakcutoff} value slightly larger than half the \textsf{cutoff} value produces reasonable 
results.  To avoid using Bethe potentials, the two parameters should be put equal to each other.


\section{The \protect\textsf{KosselDisplay.pro} program\label{sec:idl}}

\subsection{Program overview\label{sec:idloverview}}
The data files generated by the \textsf{CTEMKossel} program consist of geometrical information and Kossel patterns.
This files can be visualized using the IDL program \textsf{KosselDisplay.pro}, described in this section.

The \textsf{KosselDisplay.pro} routine requires an IDL program license or can be executed using the Virtual Machine, without the need for a license. 
If you do have a license, then make sure that the folder containing the routines is part of your IDL pathname,
and that IDL is properly installed for the UNIX shell that you will be using (csh, bsh, etc...).
To execute the program, first start an IDL session in a terminal window (using the /Appplications/Utilities/Terminal program), 
start IDL, compile the \textsf{Kosseldisplay.pro} routine by typing:
\begin{verbatim}
	IDL> .r KosselDisplay <return>
\end{verbatim}
at the IDL prompt and hitting return, followed by typing 
\begin{verbatim}
	IDL> KosselDisplay <return>
\end{verbatim}
to start the display program.  The main program widget window will appear as well as a file selector window.  
Details of all the windows are described in the following subsections.

In addition to requiring an IDL license, the program expects the X-windows environment to be installed.  On the Mac, this corresponds
to the \textsf{XQuartz} program which can be downloaded from the open source site \textsf{http://xquartz.macosforge.org/}.  This program
must be installed in the system /Applications/Utilities folder and requires OS X 10.6 or later.

Useful thing to know: if the \textsf{KosselDisplay.pro}  program hangs for some reason, you can reset your IDL session by typing
\begin{verbatim}
	IDL> .reset <return>
\end{verbatim}
This will destroy all program widgets and reset IDL to its original state.  If that does not work, then you may have to ``force quit'' the Terminal program
using the standard Esc-Option-Command key stroke.

\subsection{Main window\label{sec:idlmain}}
This display program is really very simple, and only allows for the display of Kossel patterns.
The main window contains no user adjustable parameters, and only displays a few parameters from the computation.
The main display widget when the program is started is shown in Fig.~\ref{fig:widget1}.  This program is very 
similar to that used for the display of electron channeling patterns, \textsf{ECPDisplay.pro}.

\begin{figure}[h]
\leavevmode\centering
\epsffile{figs/Kosselwidget1}
\caption{\label{fig:widget1}Main \textsf{KosselDisplay.pro} program widget.}
\end{figure}

The only user options are listed at the bottom of the widget: the \button{Kossel File} and the \button{Quit}, the latter's function being 
rather clear.  When the \button{Kossel File} is selected, a file selection interface appears, and the user can select a Kossel data file. 
Several parameters will be read from the file, and their values displayed in the main widget.  Note that both the main widget and 
the pattern display widget can be repositioned anywhere on the screen, and that the window locations will be stored in the preferences
file described in the next section.  

The pattern display widget is shown in Fig.~\ref{fig:widget2}.  The user selections are as follows:
\begin{itemize}
	\item \textbf{Integration Depth}: the \textsf{CTEMECP.f90} program generated a data file with EKPs for a number of different
	integration depths $z_0$; the user can select any of these values and the corresponding pattern will appear in the graphics area.
	Note that the EKP converges to a stable pattern after some integration depth.
	\item \textbf{Blur Radius}: Often, the EKP will contain far more detail than is visible in an experimental pattern, so the 
	parameter can be used to convolve the pattern with a Gaussian blurring kernel; the units of the blur radius are pixels.
	\item \textbf{File Format}: check boxes to determine the file format to be used when the \button{Save}\ at the bottom of the widget
	is selected.  Note that the default location for storage of the image files is the same folder in which the data file resides. 
\end{itemize}

\begin{figure}[h]
\leavevmode\centering\epsffile{figs/Kosselwidget2}
\caption{\label{fig:widget2}Kossel pattern display widget.}
\end{figure}

\subsection{Preferences file\label{sec:idlpref}}
Upon the first execution of the \textsf{KosselDisplay.pro} routine, a preferences file will be created in the user's home folder.  
The file is called \textsf{.Kosselgui.prefs}; the starting period
means that the file will not show up in a Finder window or on the UNIX command line when a simple \textsf{ls} command is issued.  This is a 
regular editable text file consisting of name::value pairs, although there is no real
need for the user to ever edit this file.  The first line shows the number of entries in the file, and then each entry is listed on a 
separate line.  A commented version of the preferences file is as follows:
\fvset{frame=lines,formatcom=\color{blue},fontsize=\footnotesize,numbers=left}
\VerbatimInput{Kosselgui-commented.prefs}
Note that the comments are not part of the actual preferences file.  All lines must be present in the file or the program will exit with an error message; the order 
of the lines is not important, but the file will always be written in the same order.
The values shown above are not default values, but represent a random snapshot of the program status after it has been used for a while.

When the program starts, it will first internally initialize all variables to default values, and then read the preferences
file, if it exists.  Then the widgets will be created using the preference values.  When the program is ended normally (by
pressing the \button{QUIT}), all current values, including the widget locations, are written to the preferences
file.

\newpage
\section{A worked example\label{sec:examples}}
In this final section, we show a simple worked example that illustrates how to use the combination of f90 and IDL programs 
to obtain a simulated Kossel pattern.  For all the examples, the input parameters in the \textsf{BetheParameters.nml} file 
should be set to \textsf{weakcutoff}$= 60$, \textsf{cutoff}$= 120$, and \textsf{sgcutoff}$=0.05$ nm$^{-1}$; note that this 
file must be located in the folder from which the programs are being executed (see comments below).

We consider the Si $[001]$ zone axis pattern and wish to compute Kossel patterns for sample thicknesses in increments of $20$ nm,
and a microscope voltage of $100$ kV, and a convergence angle of $100$ mrad. The corresponding input file is located in the 
\textsf{examples/KosselPatterns} folder and is called \textsf{Ex5.nml}:
\fvset{frame=lines,formatcom=\color{blue},fontsize=\footnotesize}
\VerbatimInput{../examples/KosselPatterns/Ex5.nml}
The Kossel program is then executed as follows:
\begin{verbatim}
	prompt> path/CTEMKossel Ex5.nml
\end{verbatim}
and the series of EKPs is computed.  The computation took about $45$ minutes on a single core on a $2\times 3.06$ GHz 6-core Intel Xeon Mac Pro (old model).
The resulting patterns are shown in Fig.~\ref{fig:ex1} for a thickness of $140$ nm (a), and $80$ nm and a blurring radius of $5$ pixels (b).


\begin{figure}[h]
\leavevmode\centering
\epsfxsize=6in\epsffile{figs/KosselExample.eps}
\caption{\label{fig:ex1}Si $[001]$ Kossel patterns for the parameters stated in the text, and the thickness values of $140$ and $80$ nm.  Intensities are 
scaled linearly, and the pattern in (b) has been blurred by a Gaussian kernel with blurring radius $5$ pixels).}
\end{figure}





\end{document}



