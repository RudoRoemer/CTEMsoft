! ###################################################################
! Copyright (c) 2014, Marc De Graef/Carnegie Mellon University
! All rights reserved.
!
! Redistribution and use in source and binary forms, with or without modification, are 
! permitted provided that the following conditions are met:
!
!     - Redistributions of source code must retain the above copyright notice, this list 
!        of conditions and the following disclaimer.
!     - Redistributions in binary form must reproduce the above copyright notice, this 
!        list of conditions and the following disclaimer in the documentation and/or 
!        other materials provided with the distribution.
!     - Neither the names of Marc De Graef, Carnegie Mellon University nor the names 
!        of its contributors may be used to endorse or promote products derived from 
!        this software without specific prior written permission.
!
! THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" 
! AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
! IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE 
! ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE 
! LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL 
! DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR 
! SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER 
! CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, 
! OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE 
! USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
! ###################################################################

!--------------------------------------------------------------------------
! EMsoft:local.f90
!--------------------------------------------------------------------------
!
! MODULE: local
!
!> @author Marc De Graef, Carnegie Mellon University
!
!> @brief definitions of single and double precision, general constants and variables
!
!> @details  
!> defines the kind-parameters for short and long integers, and single/double 
!> precision reals, as well as a few other global variables (path variables etc).
! 
!> @date 1/8/99   MDG 1.0 original
!> @date 5/6/01   MDG 2.0 f90
!> @date 11/27/01 MDG 2.1 added sgl and dbl kinds
!> @date 12/08/01 MDG 2.2 added CTEMsoft subroutine
!> @date 03/19/13 MDG 3.0 rewrite of entire package
!> @date 05/16/13 MDG 3.1 added stdout
!> @date 01/10/14 MDG 4.0 new version
!> @date 06/05/14 MDG 4.1 added comments about global variables in Release 3.0
!> @date 03/29/14 MDG 4.2 added path variable for .xtal files (which are now HDF5 files)
!> @date 04/05/15 MDG 4.3 added additional path variables and an EMsoft_path_init routine
!> @date 11/20/15 MDG 4.4 Issue 1 resolution
!> @date 02/16/16 MDG 4.5 added path delimiter conversion routines for Windows implementation
!> @date 02/25/16 MDG 4.6 added automatic generation of .config/EMsoft/EMsoftConfig.json file
!--------------------------------------------------------------------------

!---------------------------
! THIS FILE IS AUTOMATICALLY GENERATED DURING CMAKE TIME. THE ORIGINAL FILE
! LOCATED AT @CTEMSoftLib_SOURCE_DIR@/local.f90.in
! YOU NEED TO MAKE CHANGES TO THAT FILE. ANY CHANGES MADE TO THIS FILE WILL
! BE OVER WRITTEN THE NEXT TIME CMAKE IS EXECUTED.


module local

!> @note This module must be "use"d by every program, subroutine, and function!
!> These are the only global variables used by the EMsoft package.

! The entire EMsoft package should be processor independent.  This can
! be accomplished by the use of the "kind" parameters.

! Define the "kind" parameters for single and double precision reals, 
!> single precision real kind parameter
  integer,parameter                     :: sgl = SELECTED_REAL_KIND(p=6,r=37)   
!> double precision real kind parameter
  integer,parameter                     :: dbl = SELECTED_REAL_KIND(p=13,r=200) 

! Define the "kind" parameters for short and regular integers,
!> short integer kind parameter 
  integer,parameter                     :: ish = SELECTED_INT_KIND(3) 
!> long integer kind parameter  
  integer,parameter                     :: irg = SELECTED_INT_KIND(9)
!> long long kind parameter
  integer,parameter                     :: ill = SELECTED_INT_KIND(12)

!> standard string length for filenames
  integer(kind=irg),parameter           :: fnlen=132

! in Release 3.0 and beyond, this parameter has been replaced by a more flexible
! mechanism for source code version numbering using the CMake facilities.
!> source code version number
  character(8)                          :: scversion="@EMsoft_VER_MAJOR@_@EMsoft_VER_MINOR@_@EMsoft_VER_PATCH@"
!> code user name
  character(fnlen)                      :: username="Undefined"     
!> code user location
  character(fnlen)                      :: userlocn="Undefined"
!> code user email
  character(fnlen)                      :: useremail="Undefined"
!> platform
  character(fnlen)                      :: EMsoftplatform="@CMAKE_SYSTEM_NAME@"
!> pathnamedelimiter
  character(1)                          :: EMsoftnativedelimiter
  
!> reserved IO unit identifiers for postscript (20) and data (21-23)
  integer(kind=irg), parameter          :: psunit=20, dataunit=21, dataunit2=22, dataunit3=23

! parameters governing the size of varous arrays
!> Maximum number of positions in asymmetric unit
  integer(kind=irg), parameter          :: maxpasym=250         
!> Maximum number of defects of any given type
  integer(kind=irg), parameter          :: maxdefects=250
!> max number of templates in templatecodes.txt file
  integer(kind=irg), parameter          :: maxnumtemplates = 256

! ================================
! 06/08/14 the entries below are global variables 
! ================================

!> pathnames to the namelist template files
! This should be reworked via CMake commands
  character(fnlen)                      :: EMsoftpathname
!DEC$ ATTRIBUTES DLLEXPORT :: EMsoftpathname
  character(fnlen)                      :: EMdatapathname
!DEC$ ATTRIBUTES DLLEXPORT :: EMdatapathname
  character(fnlen)                      :: templatepathname 
!DEC$ ATTRIBUTES DLLEXPORT :: templatepathname
  character(fnlen)                      :: EMtmppathname 
!DEC$ ATTRIBUTES DLLEXPORT :: EMtmppathname
  character(fnlen)                      :: resourcepathname
!DEC$ ATTRIBUTES DLLEXPORT :: resourcepathname
  character(fnlen)                      :: openclpathname
!DEC$ ATTRIBUTES DLLEXPORT :: openclpathname
  character(fnlen)                      :: xtalpathname
!DEC$ ATTRIBUTES DLLEXPORT :: xtalpathname
  character(fnlen)                      :: templatecodefilename 
!DEC$ ATTRIBUTES DLLEXPORT :: templatecodefilename
  character(fnlen)                      :: randomseedfilename 
!DEC$ ATTRIBUTES DLLEXPORT :: randomseedfilename


contains

!--------------------------------------------------------------------------
! EMsoft2013:local:EMsoft.f90
!--------------------------------------------------------------------------
!
! SUBROUTINE: EMsoft
!
!> @author Marc De Graef, Carnegie Mellon University
!
!> @brief prints a copyright statement and the program name
!
!> @details prints a copyright statement as well as where the user can find the license information 
!> This is then followed by the program name, a one-line description, and a time stamp.
! 
!> @param progname program name string
!> @param progdesc program descriptor string
!> @param stdout optional output unit identifier
!> @param config optional passed on to EMsoft_path_init
!
!> @date  12/08/01 MDG 1.0 original
!> @date  03/19/13 MDG 2.0 minor modifications
!> @date  05/16/13 MDG 2.1 added timestamp and stdout
!> @date  01/10/14 MDG 3.0 new version
!> @date  06/05/14 MDG 4.0 progname and progdesc are now subroutine arguments; made stdout optional
!> @date  02/25/16 MDG 4.1 added config optional parameter 
!--------------------------------------------------------------------------

subroutine EMsoft(progname,progdesc,stdout,config)
!DEC$ ATTRIBUTES DLLEXPORT :: EMsoft

IMPLICIT NONE

character(fnlen),INTENT(IN)           :: progname
character(fnlen),INTENT(IN)           :: progdesc
integer(kind=irg),INTENT(IN),OPTIONAL :: stdout
logical,INTENT(IN),OPTIONAL           :: config

integer(kind=irg)                     :: std 

 std = 6
 if (PRESENT(stdout)) std=stdout

 write (std,"(//1x,'EMsoft version ',A,', Copyright (C) 2001-2016 Marc De Graef Research Group/CMU')") trim(scversion)
 write (std,"(1x,'EMsoft comes with ABSOLUTELY NO WARRANTY.')")
 write (std,"(1x,'This is free software, and you are welcome to redistribute it')")
 write (std,"(1x,'under certain conditions; see License.txt file for details.'//)")

 write (std,"(1x,'Program name : ',A)") trim(progname)
 write (std,"(1x,A/)") trim(progdesc)
 write (std,"(1x,'Platform : ',A/)") trim(EMsoftplatform)

 call timestamp(std)
 write (std,"(1x,/)")

 if (present(config)) then ! we need to (re-)create the EMsoftConfig.json file...
    if (config.eqv..TRUE.) then
      call EMsoft_path_init(config)
    end if
 else
   call EMsoft_path_init
 end if
 
end subroutine EMsoft


!--------------------------------------------------------------------------
! EMsoft:local:EMsoft_toNativePath.f90
!--------------------------------------------------------------------------
!
! FUNCTION: EMsoft_toNativePath
!
!> @author Marc De Graef, Carnegie Mellon University
!
!> @brief convert a path string from the native format to the other one
!
!> @param inpath input path string
!
!> @date  02/16/16 MDG 1.0 new routine
!--------------------------------------------------------------------------
function EMsoft_toNativePath(inpath) result(outpath)
!DEC$ ATTRIBUTES DLLEXPORT :: EMsoft_toNativePath

IMPLICIT NONE

character(fnlen),INTENT(IN)          :: inpath
character(fnlen)                     :: outpath

integer(kind=irg)                    :: i, slen
character(1)                         :: todelim, fromdelim, c

slen = len(inpath)
outpath = ''
todelim = EMsoftnativedelimiter

if (todelim.eq.'\') then
  fromdelim = '/'
else
  fromdelim = '\'
end if

do i=1,slen
  c = inpath(i:i)
  if (c.eq.fromdelim) c = todelim
  outpath(i:i) = c
end do

end function EMsoft_toNativePath

!--------------------------------------------------------------------------
! EMsoft:local:EMsoft_fromNativePath.f90
!--------------------------------------------------------------------------
!
! FUNCTION: EMsoft_fromNativePath
!
!> @author Marc De Graef, Carnegie Mellon University
!
!> @brief convert a path string to the native format on this platform
!
!> @param inpath input path string 
!
!> @date  02/16/16 MDG 1.0 original version 
!--------------------------------------------------------------------------
function EMsoft_fromNativePath(inpath) result(outpath)
!DEC$ ATTRIBUTES DLLEXPORT :: EMsoft_fromNativePath

IMPLICIT NONE

character(fnlen),INTENT(IN)          :: inpath
character(fnlen)                     :: outpath

integer(kind=irg)                    :: i, slen
character(1)                         :: todelim, fromdelim, c

slen = len(inpath)
outpath = ''
fromdelim = EMsoftnativedelimiter

if (fromdelim.eq.'/') then
  todelim = '\'
else
  todelim = '/'
end if

do i=1,slen
  c = inpath(i:i)
  if (c.eq.fromdelim) c = todelim
  outpath(i:i) = c
end do

end function EMsoft_fromNativePath



!--------------------------------------------------------------------------
! EMsoft2013:local:EMsoft_path_init.f90
!--------------------------------------------------------------------------
!
! SUBROUTINE: EMsoft_path_init
!
!> @author Marc De Graef, Carnegie Mellon University
!
!> @brief Reads environment variables and sets appropriate path variables
!
!> @param no parameters
!
!> @date  05/05/15 MDG 1.0 new routine
!> @date  09/26/15 MDG 1.1 added .json config support
!> @date  11/20/15 MDG 1.2 added UserName, UserLocation, and UserEmail options
!> @date  02/25/16 MDG 1.4 added optional config parameter
!--------------------------------------------------------------------------

subroutine EMsoft_path_init(config)
!DEC$ ATTRIBUTES DLLEXPORT :: EMsoft_path_init

use json_module
use, intrinsic :: iso_fortran_env , only: error_unit, wp => real64


IMPLICIT NONE

logical,INTENT(IN),OPTIONAL             :: config

character(fnlen)                        :: pathstring, dirstring, ep
type(json_file)                         :: json
integer(kind=irg)                       :: i, error_cnt
character(kind=CK,len=:),allocatable    :: cval
logical                                 :: found, fexists, jexists
character(fnlen)                        :: confname, emsoftname, jsonname, jsonfilename, fname, cwd, &
                                           dirname, library, dataname, xtalname
character(3)                            :: release
character(len=1)                        :: edp, tab, yesno

edp = '"'
tab = CHAR(9)
yesno = 'n'
EMsoftpathname = ''
EMdatapathname = ''

! default names for the json configuration file
confname = '.config'
emsoftname = 'EMsoft'
jsonfilename = 'EMsoftConfig.json'

! determine the pathname delimiter character
if (trim(EMsoftplatform).eq.'Windows') then
  EMsoftnativedelimiter = '\'
else
  EMsoftnativedelimiter = '/'
end if 

! get the user's home directory to prepend to the config file name
if (trim(EMsoftplatform).eq."Windows") then
! TO BE COMPLETED AND TESTED
! call getenv("HOME",dirstring)
! jsonname = trim(dirstring)//'/.config/EMsoft/EMsoftConfig.json'
else
  call getenv("HOME",dirstring)
  jsonname = trim(dirstring)//EMsoftnativedelimiter//trim(confname)//EMsoftnativedelimiter// &
             trim(emsoftname)//EMsoftnativedelimiter//trim(jsonfilename)
end if

! test whether or not this file actually exists
inquire(file=trim(jsonname),exist=jexists)

! if this routine is called with config=.TRUE. parameter, then that means that we
! must create a new EMsoftConfig.json file if it doesn't already exist; we will inform
! the user if it does exist, and rename the existing file
if (present(config)) then
  if (config.eqv..TRUE.) then
    call getcwd(cwd)
    fname = trim(cwd)//EMsoftnativedelimiter//'EMsoftinit'
    inquire(file=trim(fname),exist=fexists)
    if (.not.(fexists)) then
      write (*,*) 'Please execute the EMsoftinit program from inside the EMsoft Bin or bin folder'
      stop
    end if 
    if (jexists) then 
! first of all, we need to figure out where the EMsoftinit executable is located
      write (*,*) '-------'
      write (*,*) 'WARNING: An older configuration file already exists in the .config/EMsoft folder'
      write (*,*) '         The existing file will be renamed and a new file created.'
      write (*,"(/'          Do you want to continue ? (y/n) ',$)")
      read(*,"(A1)") yesno
      if (yesno.eq.'n') then 
        stop 'program terminated'
      end if
      write (*,*) '         Renaming old file to ',trim(jsonname)//'.save'
      write (*,*) '         Creating new configuration file'
      write (*,*) '-------'
      call system('mv '//trim(jsonname)//' '//trim(jsonname)//'.save')
    end if
    jexists = .FALSE.
  end if
end if

if (jexists) then ! this is not the first time an EMsoft program is executed... 
! initialize the json state variables
  error_cnt = 0
  call json_initialize()
  if (json_failed()) then
    call json_print_error_message(error_unit)
    stop
  end if

! and load the file
  call json%load_file(filename = trim(jsonname))
  if (json_failed()) then    !if there was an error reading the file
    call json_print_error_message(error_unit)
    stop
  end if

! if we find the field 'ep' in the file, then we read its corresponding value;
! if either one of the main variables EMsoftpathname or EMdatapathname is not there, then we abort
  ep = 'EMsoftpathname'
  call json%get(trim(ep), cval, found)
  if (.not. found) then
    write(error_unit,'(A)') 'WARNING: field '//trim(ep)//' not found in json file'
    stop
  else
    EMsoftpathname = trim(cval)
  end if

  ep = 'EMdatapathname'
  call json%get(trim(ep), cval, found)
  if (.not. found) then
    write(error_unit,'(A)') 'WARNING: field '//trim(ep)//' not found in json file'
    stop
  else
    EMdatapathname = trim(cval)
  end if

  ep = 'EMtmppathname'
  call json%get(trim(ep), cval, found)
  if (.not. found) then
    write(error_unit,'(A)') 'WARNING: field '//trim(ep)//' not found in json file'
  else
    EMtmppathname = trim(cval)
  end if

  ep = 'UserName'
  call json%get(trim(ep), cval, found)
  if (found) then
    username = trim(cval)
  end if
  
  ep = 'UserLocation'
  call json%get(trim(ep), cval, found)
  if (found) then
    userlocn = trim(cval)
  end if

  ep = 'UserEmail'
  call json%get(trim(ep), cval, found)
  if (found) then
    useremail = trim(cval)
  end if

! and cleanup
  call json%destroy()
else  ! the config file does not exist, so we create it with "smart" default values

! next, we look for the .config/EMsoft/EMsoftConfig.json file one step at a time
  call getenv("HOME",dirstring)
  call chdir(trim(dirstring))

! check for the .config folder
  dirname = trim(dirstring)//EMsoftnativedelimiter//trim(confname)
  inquire(file=trim(dirname),exist=fexists)
  if (.not.(fexists)) then
    call system('mkdir '//trim(dirname))
  end if
  call chdir(trim(dirname))

! check for the EMsoft folder
  dirname = trim(dirname)//EMsoftnativedelimiter//'EMsoft'
  inquire(file=trim(dirname),exist=fexists)
  if (.not.(fexists)) then
    call system('mkdir '//trim(dirname))
  end if
  call chdir(trim(dirname))

! check whether or not the tmp folder exists...
  fname = trim(dirname)//EMsoftnativedelimiter//'tmp'
  inquire(file=trim(dirname),exist=fexists)
  if (.not.(fexists)) then
    call system('mkdir '//trim(dirname))
  end if

! ok, so we have created the correct folder structure; now we need to generate the 
! EMsoftConfig.json file

! first, guess at where the EMsoft main folder is located; we'll check if this is 
! a Debug or release version
  i = index(trim(cwd),'Build')
  if (i.gt.0) then   ! this is an EMsoft Build, not a release package
    release = 'No'
! get the substring upto '/Build'
    EMsoftpathname = cwd(1:i-2)
  else
    release = 'Yes'
    i = index(trim(cwd),'bin')
    EMsoftpathname = cwd(1:i-2)
  end if

! the default EMdata folder is at the same level as EMsoft, so we 
! we initialize this variable
  i = index(trim(EMsoftpathname),'EMsoft')
  if (i.eq.0) then
    write (*,*) '------'
    write (*,*) 'Installation problem !!!'
    write (*,*) 'The top folder of this package *must* be called EMsoft'
    write (*,*) '------'
    stop  
  else
    EMdatapathname = EMsoftpathname(1:i-2)//EMsoftnativedelimiter//'EMdata'
  end if

! if EMdata does not exist, create it and also create an XtalFolder inside of it.
  dataname = trim(EMdatapathname)
  inquire(file=trim(dataname),exist=fexists)
  if (.not.(fexists)) then
    call system('mkdir '//trim(dataname))
    write (*,*) trim(dataname),' folder did not exist and has been created'
  end if
  xtalname = trim(dataname)//EMsoftnativedelimiter//'XtalFolder'
  inquire(file=trim(xtalname),exist=fexists)
  if (.not.(fexists)) then
    call system('mkdir '//trim(xtalname))
    write (*,*) trim(xtalname),' folder did not exist and has been created'
  end if

! library location
  library = ''
  if (release.eq.'Yes') then
    library = trim(EMsoftpathname)//'/lib'
  else
    library = trim(EMsoftpathname)//'/Build/Bin'
  end if

! generate the json file
  open(unit=dataunit,file=trim(jsonname),status='new',form='formatted')
  write (dataunit,"('{')")
  write (dataunit,"(A,A,'EMsoftpathname',A,': ',A,A,A,',')") tab, edp, edp, edp, trim(EMsoftpathname)//'/',edp
  write (dataunit,"(A,A,'EMdatapathname',A,': ',A,A,A,',')") tab, edp, edp, edp, trim(EMdatapathname)//'/',edp
  write (dataunit,"(A,A,'EMtmppathname',A,': ',A,A,A,',')") tab, edp, edp, edp, trim(fname)//'/',edp
  write (dataunit,"(A,A,'EMsoftLibraryLocation',A,': ',A,A,A,',')") tab, edp, edp, edp, trim(library)//'/',edp
  write (dataunit,"(A,A,'Release',A,': ',A,A,A,',')") tab, edp, edp, edp, trim(release), edp
  
  write (*,*) '------'
  write (*,*) 'Please respond to the following questions (each entry should be less than 132 characters)'
  write(*,"(A,$)") '  Enter your user name : '
  read(*,"(A)") username
  write (dataunit,"(A,A,'UserName',A,': ',A,A,A,',')") tab, edp, edp, edp, trim(username), edp

  write(*,"(A,$)") '  Enter your email address : '
  read(*,"(A,$)") useremail
  write (dataunit,"(A,A,'UserEmail',A,': ',A,A,A,',')") tab, edp, edp, edp, trim(useremail), edp

  write(*,"(A,$)") '  Enter your affiliation : '
  read(*,"(A,$)") userlocn
  write (dataunit,"(A,A,'UserLocation',A,': ',A,A,A)") tab, edp, edp, edp, trim(userlocn), edp

  write (dataunit,"('}')")
  close(unit=dataunit,status='keep')

  write (*,"(/' A new EMsoftConfig.json file has been created in the .config/EMsoft folder.')")
  write (*,"(' You can edit this file to change the parameters as needed.')")
  write (*,"(' Every EMsoft program will read the configuration file to figure out where things are located.'/)")

end if

! define the derived pathname variables (globals)
templatepathname = trim(EMsoftpathname)//'templatefolder/'
resourcepathname = trim(EMsoftpathname)//'resources/'
openclpathname = trim(EMsoftpathname)//'opencl/'
xtalpathname = trim(EMdatapathname)//'XtalFolder/'
templatecodefilename = trim(resourcepathname)//'templatecodes.txt'
randomseedfilename = trim(resourcepathname)//'RandomSeeds.data'

end subroutine EMsoft_path_init


!--------------------------------------------------------------------------
!
! subroutine: timestamp
!
!> @author John Burkardt
!
!> @brief prints the current YMDHMS date as a time stamp.
!
!> @note  This code is distributed under the GNU LGPL license. 
!
!> @param stdout output unit identifier
!
!> @date 05/31/01  JB original
!> @date 05/01/13 MDG changed 'm' to 'mo' for month variable, and some other minor changes
!> @date 06/05/14 MDG added stdout as optional argument
!> @date 03/19/15 MDG added timestring and datestring optional arguments
!--------------------------------------------------------------------------
subroutine timestamp(stdout, timestring, datestring)
!DEC$ ATTRIBUTES DLLEXPORT :: timestamp

  IMPLICIT NONE
  
  integer(kind=irg),INTENT(IN),OPTIONAL    :: stdout
  character(len = 11),INTENT(OUT),OPTIONAL :: datestring
  character(len = 15),INTENT(OUT),OPTIONAL :: timestring

  integer(kind=irg)      :: std
  character ( len = 8 )  :: ampm
  integer ( kind = irg ) :: d
  character ( len = 8 )  :: date
  integer ( kind = irg ) :: h
  integer ( kind = irg ) :: mo
  integer ( kind = irg ) :: mm
  character ( len = 3 ), parameter, dimension(12) :: month = (/ &
    'Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec' /)
  integer ( kind = irg ) :: n
  integer ( kind = irg ) :: s
  character ( len = 10 ) :: time
  integer ( kind = irg ) :: values(8)
  integer ( kind = irg ) :: y
  character ( len = 5 )  :: zone

  std = 6
  if (PRESENT(stdout)) std=stdout

  call date_and_time ( date, time, zone, values )

  y = values(1)
  mo = values(2)
  d = values(3)
  h = values(5)
  n = values(6)
  s = values(7)
  mm = values(8)

  if ( h < 12 ) then
    ampm = 'AM'
  else if ( h == 12 ) then
    if ( n == 0 .and. s == 0 ) then
      ampm = 'Noon'
    else
      ampm = 'PM'
    end if
  else
    h = h - 12
    if ( h < 12 ) then
      ampm = 'PM'
    else if ( h == 12 ) then
      if ( n == 0 .and. s == 0 ) then
        ampm = 'Midnight'
      else
        ampm = 'AM'
      end if
    end if
  end if

  if ((.not.PRESENT(datestring)).and.(.not.PRESENT(timestring))) then
    write ( std, '(a1,a3,1x,i2,1x,i4,2x,i2,a1,i2.2,a1,i2.2,a1,i3.3,1x,a)' ) &
      ' ',month(mo), d, y, h, ':', n, ':', s, '.', mm, trim ( ampm )
  else
    if (PRESENT(datestring)) write (datestring, '(a,1x,i2,1x,i4)' ) month(mo), d, y
    if (PRESENT(timestring)) then
      write (timestring, '(i2,a1,i2.2,a1,i2.2,a1,i3.3,1x,a)' ) h,':',n,':',s,'.',mm,trim(ampm)
    end if
  end if

end subroutine timestamp



end module local
